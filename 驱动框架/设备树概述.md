概述

设备树 DT（Device Tree）是一种 数据结构，  --- arm 架构使用

用于 描述 硬件设备 及其 配置信息，包括CPU，内存，总线和其他一些外设。

它通常用于嵌入式系统中，尤其是在 Linux 操作系统中，帮助操作系统识别和管理硬件资源。

设备树不是代码，而是一种用数据描述硬件信息的方式。

扁平/开放设备树 FDT（Flattened Device Tree），起源于 OpenFirmware（OF） --- 其他架构使用

设备树的作用

Linux内核从 3.x版本之后 开始 支持使用设备树，可以实现驱动代码与设备的硬件信息相互的隔离，减少了代码中的耦合性

驱动文件：drive.c  ---假设有一个 led 灯 驱动

设备文件：device.c   --- 描述 led 灯 硬件资源文件 --- 用哪一个引脚、触发状态（高电平、低电平）

引入设备树之前：

一般 device 部分代码会放在 内核源码中 arch/arm/plat-xxx 和 arch/arm/mach-xxx 下面。

随着 Linux 支持的硬件越来越多，在内核源码下关于硬件描述的代码也越来越多。

因为设备有非常多种，如果 外设发生相应的变化，那么 device.c 就需要改动，并且每改一次都要编译一次内核。长此以往 Linux内核中 存在 大量 垃圾代码。

引入设备树之后：用 设备树 描述 硬件信息，代替原来的 device 部分的代码。虽然用设备树 替换了 原来的 device 部分，但是平台总线模型的匹配和使用基本不变。

驱动代码只要负责处理逻辑，而关于设备的具体信息存放到设备树文件中。如果只是硬件接口信息的变化而没有驱动逻辑的变化，开发者只需要修改设备树文件信息，不需要改写驱动代码。

设备树在嵌入式系统，尤其是ARM架构中有广泛应用，主要作用如下：

1. ﻿﻿硬件描述：设备树的最大作用就是描述硬件。它将硬件的详细信息（如设备的地址、IRQ、中断号等） 提供给操作系统。这样，操作系统就能够知道硬件的具体信息，从而正确地驱动和管理硬件设备。
2. ﻿﻿硬件与内核解耦：传统的硬件驱动程序通常依赖于固定的硬件信息（如硬件地址、IRQ等），这使得内核与硬件绑定较紧密，修改硬件时需要修改内核代码。设备树的出现使得操作系统能够通过读取设备树来动态获取硬件信息，从而提高了硬件和操作系统之间的解耦性。|  
    例如，设备树可以描述不同硬件平台的差异，而不需要修改内核代码。
3. ﻿﻿﻿支持多平台：设备树使得操作系统可以支持多种硬件平台（如不同的开发板、SOC （System on Chip） 等）。不同的硬件可以通过不同的设备树描述一而操作系统内核本身不需要做出太多的修改。因此，设备树为多平台支持提供了一种通用的解决方案，极大简化了移植过程。
4. ﻿﻿﻿简化硬件配置：在传统的设备配置中，硬件配置往往嵌入内核源代码中。而设备树通过集中管理硬件信息，将所有硬件的配置信息放在一个地方，便于管理和修改。这种方式使得硬件的配置更加灵活，避免了重新编译内核来更改硬件配置的麻烦。
5. ﻿﻿减少内核定制：在嵌入式开发中，不同的硬件平台（如不同的开发板或50C）有不同的硬件配置。使用设备树，可以减少针对每种硬件定制内核的工作。只需要编写或修改相应的设备树文件，内核就可以通过设备树加载正确的硬件配置信息。
6. ﻿﻿简化驱动程序编写：在没有设备树之前，硬件驱动程序通常需要硬编码硬件的配置参数（如基地址、IRQ等）。而有了设备树，驱动程序通过读取设备树中的配置，可以使驱动程序与硬件配置解耦，从而减少了硬件驱动的复杂性和维护难度。

设备树的结构

设备树通常是以一种 树形结构 来表示 硬件各个部分的层次关系。

包含 多个节点，每个节点代表一个硬件设备或设备的某些特性。每个节点可以包含一些属性，描述该设备的详细信息。例如：

- ﻿节点：代表硬件设备，比如CPU、内存、串口、存储、网络接口等。
- ﻿属性：描述该设备的特性或配置信息，如设备的地址、类型、IRQ（中断请求）、驱动程序等。


设备树名词解释
![[DST.png]]

- DTS（纯文本文件）

设备树源码文件，硬件的相应信息都会写在.dts为后缀的文件中，每一款硬件可以单独写一份xxxx.dts

- DTSI（通用设备树源码）

对于一些相同的dts配置可以抽象到dtsi文件中，然后可以用include的方式到dts文件中

不同开发板 芯片可能是一样的，

同一芯片可以做一个dtsi，不同的板子不同的dts，然后include同一dtsi

对于同一个节点的设置情况，dts中的配置会覆盖dtsi中的配置

- DTC

dtc是 编译dts的工具

- DTB

dts 经过 dtc 编译之后 会得到dtb文件，设备树的 二进制执行文件

DTS头文件

在.dts 设备树文件中，可以通过“#include”来引用.h、.dtsi 和.dts 文件

- 全局绑定宏定义头文件

|   |
|---|
|#include <dt-bindings/input/input.h>|

路径：

include/dt-bindings/input/input.h

作用：

定义了 Linux 内核通用的 输入设备事件码（input event code），例如按键类型、按键 ID。

示例内容：

#define KEY_RESERVED        0  
#define KEY_ESC             1  
#define KEY_1               2  
#define KEY_A               30  
#define BTN_TOUCH           330  
#define BTN_TOOL_FINGER     325

用法场景：

你在设备树中定义按键时，会用这些宏名替代数字：

key {  
    linux,code = <KEY_A>;     // 相当于 code = 30  
    label = "MyKeyA";  
}

- 继承厂商 通用设备树 dtsi

例如：NXP（飞思卡尔）的 i.MX6 SoC 设备树文件

|   |
|---|
|#include "imx6ull.dtsi"|

可能路径：

arch/arm/boot/dts/imx6ull.dtsi    #32位 开发板

arch/arm64/boot/dts/相关平台/imx6ull.dtsi   #64位 开发板

dtsi 包含：

- CPU 节点
- 中断控制器
- 内存映射（memory map）
- 外设控制器（UART、I2C、SPI 等）

用法场景：

写一个板级设备树 .dts 文件时，会引用这个 .dtsi 来继承 SoC 基础结构。

soc {

    compatible = "simple-bus";

    ranges;

    uart1: serial@2020000 {

        compatible = "fsl,imx6ul-uart", "fsl,imx21-uart";

        reg = <0x02020000 0x4000>;

        ...

    };

};

编译设备树

- dtc 位置：

linux-6.6.84/scripts/dtc/dtc

linux 内核源码编译后 会出现 dtc 文件，如果没有，

修改 根目录 下的 .config 文件：CONFIG_DTC=y

- 编译设备树命令： dts  -> dtb

内核源码绝对路径/dtc -I dts -O dtb -o xxx.dtb  xxx.dts

-I dts 输入 dts 格式文件

-O dtb 输出 dtb 格式文件

-o xxx.dtb  输出文件的文件名

xxx.dts  要编译的设备树源码

- 反编译设备树命令： dtb  -> dts

内核源码绝对路径/dtc -I dtb -O dts -o xxx.dts  xxx.dtb

- 编译 arch/arm/boot/dts/ 目录下 设备树命令：

make dtbs